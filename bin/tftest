#!/usr/bin/env node
const fs = require('fs');
const os = require('os');
const path = require('path');
const program = require('commander');
const Plan = require('../lib/plan.js');
const Runner = require('../lib/runner.js');
const { getTfJson } = require('../lib/generic.js');
const packageJson = require('../package.json');

program.version(packageJson.version);

program.command('test')
       .description('test')
       .option('-t, --terraformFolder <terraformFolder>', 'Path of terraform modules folder <terraformFolder> (Default: ' + process.cwd() + ' )')
       .option('-p, --terraformPlan <terraformPlan>', 'Path of terraform modules plan <terraformPlan> (Default: ' + path.join(process.cwd(), 'output.plan') + ' )')
       .action((options) => {
         let tfFolder = options.terraformFolder ? options.terraformFolder : process.cwd();
         let tfPlan = options.terraformPlan ? options.terraformPlan : path.join(process.cwd(), 'output.plan');
         const cliRun = new Runner(tfFolder, tfPlan);
         cliRun.setupJasmine();
         cliRun.execute();
       });

program.command('show')
      .description('show')
      .option('-p, --terraformPlan <terraformPlan>', 'Path of terraform modules plan <terraformPlan> (Default: ' + path.join(process.cwd(), 'output.plan') + ' )')
      .action((options) => {
        let tfPlan = options.terraformPlan ? options.terraformPlan : path.join(process.cwd(), 'output.plan');
        let output = JSON.stringify(new Plan(tfPlan).plan, null, 2);
        console.log(output);
        return output;
      });

program.command('gettfjson')
      .description('gettfjson', 'Download tfjson')
      .action((options) => {
        const osString = (process.platform === 'win32') ? 'windows' : process.platform;
        const archString = (os.arch() === 'x64') ? 'amd64' : 'i386';
        const tfjsonRelease = packageJson.binaryDependencies.tftest;
        getTfJson(osString, archString, tfjsonRelease);
      });

program.parse(process.argv);

module.exports = {
    program
}
